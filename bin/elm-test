#!/usr/bin/env node

var processTitle = "elm-test";

process.title = processTitle;

process.on('uncaughtException', function(error) {
  if (/ an argument in Javascript/.test(error)) {
    // Handle arg mismatch between js and elm code. Expected message from Elm:
    // "You are giving module `Main` an argument in JavaScript.
    // This module does not take arguments though! You probably need to change the
    // initialization code to something like `Elm.Test.Generated.Main.fullscreen()`]"
    console.error("Error starting the node-test-runner.");
    console.error("Please check your Javascript 'elm-test' and Elm 'node-test-runner' package versions are compatible");
  } else {
    console.error("Unhandled exception while running the tests:", error);
  }
});

var compile    = require("node-elm-compiler").compile,
  fs           = require("fs-extra"),
  glob         = require("glob"),
  chalk        = require("chalk"),
  path         = require("path"),
  temp         = require("temp").track(), // Automatically cleans up temp files.
  util         = require("util"),
  _            = require("lodash"),
  spawn        = require("cross-spawn"),
  minimist     = require("minimist"),
  firstline    = require("firstline"),
  chokidar     = require("chokidar"),
  Runner       = require("../lib/runner.js"),
  doctest      = require("elm-doc-test/bin/modes");

var generatedCodeDir = "elm-stuff/generated-code/elm-community/elm-test"
var elm = {
  'elm-package': 'elm-package'
};
var args = minimist(process.argv.slice(2), {
    alias: {
        'help': 'h',
        'yes': 'y',
        'seed': 's',
        'compiler': 'c',
        'report': 'r',
        'watch': 'w'
    },
    boolean: [ 'yes', 'warn', 'version', 'help', 'watch'],
    string: [ 'compiler', 'seed', 'report' ]
});

var globPattern = args._[0] || "tests/**/*.elm";
var testFilePaths = glob.sync(
    globPattern,
    {nocase: true, ignore: "**/elm-stuff/**", nodir: true}
  ).map(function(filename) { return path.resolve(filename); }),
  pathToMake = undefined;
var testFilenameSet = new Set(testFilePaths);


if (args.help) {
  console.log("Usage: elm-test init [--yes]  # Create example tests\n");
  console.log("Usage: elm-test TESTFILE [--compiler /path/to/compiler] # Run TESTFILE\n");
  console.log("Usage: elm-test [--compiler /path/to/compiler] # Run tests/\n");
  console.log("Usage: elm-test [--seed integer] # Run with initial fuzzer seed\n");
  console.log("Usage: elm-test [--report json or chalk (default)] # Print results to stdout in given format\n");
  console.log("Usage: elm-test [--watch] # Run tests on file changes\n");
  process.exit(1);
}

if (args.version) {
  console.log(require(path.join(__dirname, "..", "package.json")).version);
  process.exit(0);
}


// Run elm-doc-tests
var doctestModel = doctest.init({
  warn: false,
  output: path.join(generatedCodeDir, 'src')
});


if (doctestModel.config.tests.length <= 0) {
  runElmTest(); // only run elm-tests
} else {
  doctestModel.run(doctestModel, function () {
    // Run elm-tests
    runElmTest();
  });
}

function runElmTest() {
  var report = "chalk";
  if (args.report === "chalk" || args.report == "json") {
      report = args.report;
  } else if (args.report !== undefined) {
      console.error("The --report option must be given either 'chalk' or 'json'");
      process.exit(1);
  }

  checkNodeVersion();

  function checkNodeVersion() {
    var nodeVersionString = process.versions.node;
    var nodeVersion = _.map(_.split(nodeVersionString, '.'), _.parseInt);

    if((nodeVersion[0] === 0 && nodeVersion[1] < 11) ||
       (nodeVersion[0] === 0 && nodeVersion[1] === 11 && nodeVersion[2] < 13)) {
      console.log("using node v" + nodeVersionString);
      console.error("elm-test requires node v4.7.0 or greater - upgrade the installed version of node and try again");
      process.exit(1);
    }
  }

  if (args._[0] == "init") {
    var copyTemplate = function(templateName, destName) {
      if (arguments.length == 1) {
        destName = templateName;
      }
      var source = path.resolve(__dirname, "../templates/" + templateName);
      var destination = path.resolve("tests", destName);
      if (fs.existsSync(destination)) {
        console.log(destination + " already exists");
      } else {
        fs.copySync(source, destination);
        console.log("Created " + destination);
      }
    };

    var ensureDirectory = function(dirName) {
      var destination = path.resolve(".", dirName);
      if (fs.existsSync(destination)) {
        console.log(destination + " already exists");
      } else {
        fs.mkdirSync(destination);
        console.log("Created " + destination);
      }
    };

    var elmOptions = "";
    if (args.yes) {
      elmOptions += " --yes";
    }

    ensureDirectory("src");
    ensureDirectory("tests");
    copyTemplate("elm-package.json");
    copyTemplate("Tests.elm");
    copyTemplate("gitignore", ".gitignore");
    process.exit(0);
  }

  function evalElmCode (compiledCode) {
    // Apply Node polyfills as necessary.
    var window = {Date: Date, addEventListener: function() {}, removeEventListener: function() {}};
    var document = {body: {}, createTextNode: function() {}};
    if (typeof XMLHttpRequest === 'undefined') { XMLHttpRequest = function() { return { addEventListener: function() {}, open: function() {}, send: function() {} }; }; }
    if (typeof FormData === 'undefined') { FormData = function () { this._data = []; }; FormData.prototype.append = function () { this._data.push(Array.prototype.slice.call(arguments)); }; }

    var Elm = function(module) { eval(compiledCode); return module.exports; }({});

    // Make sure necessary things are defined.
    if (typeof Elm === 'undefined') { throw 'elm-io config error: Elm is not defined. Make sure you provide a file compiled by Elm!'; }

    var testModule = Elm.Test.Generated.Main;
    var initialSeed = null;

    if (args.seed !== undefined) {
      initialSeed = args.seed;
    }

    pathToMake = args.compiler;

    // Fix Windows Unicode problems. Credit to https://github.com/sindresorhus/figures for the Windows compat idea!
    var windowsSubstitutions = [[/[↓✗►]/g, '>'], [/╵│╷╹┃╻/g, '|'], [/═/g, '='],, [/▔/g, '-'], [/✔/g, '√']];

    function windowsify(str) {
      return windowsSubstitutions.reduce(
        function(result, sub) { return result.replace(sub[0], sub[1]); }, str);
    }

    function chalkify(messages) {
      return messages.map(function(msg) {
        var path = msg.styles;
        var text = process.platform === 'win32' ? windowsify(msg.text) : msg.text;

        if (path.length === 0) {
          return text;
        } else {
          var fn = chalk;

          path.forEach(function(nextPath) { fn = fn[nextPath]; });

          return fn(text);
        }
      }).join('');
    }

    // Run the Elm app.
    var app = testModule.worker({seed: initialSeed, report: report});

    // Receive messages from ports and translate them into appropriate JS calls.
    app.ports.emit.subscribe(function(msg) {
      var msgType = msg[0];
      var data = msg[1];

      if (msgType === 'FINISHED') {
        if (data.format === "CHALK") {
          console.log(chalkify(data.message));
        } else {
          console.log(JSON.stringify(data.message));
        }

        if (!args.watch) {
          process.exit(data.exitCode);
        }
      } else if (msgType === "STARTED" || msgType === "TEST_COMPLETED")  {
          if (data.format === "CHALK") {
            console.log(chalkify(data.message));
          } else {
            console.log(JSON.stringify(data.message));
          }

      }
    });
  }


  var testsPath = args._[0],
      pathToMake = undefined;

  function spawnCompiler(cmd, args, opts) {
    var compilerOpts =
        _.defaults({stdio: [process.stdin, report === "chalk" ? process.stdout : 'ignore', process.stderr] }, opts);

    return spawn(cmd, args, compilerOpts);
  }

  if (args.compiler !== undefined) {
    pathToMake = args.compiler;

    if (!pathToMake) {
      console.error("The --compiler option must be given a path to an elm-make executable.");
      process.exit(1);
    }
  }

  function infoLog(msg) {
    if (report === "chalk") {
      console.log(msg);
    }
  }

  var elmRootDir = Runner.findNearestElmPackageDir(testFilePaths);
  var elmPackagePath = path.join(elmRootDir, "elm-package.json");
  if (fs.realpathSync(elmRootDir) !== fs.realpathSync(process.cwd())) {
      process.chdir(elmRootDir);
  }

  // TODO we don't want to do this every single time. Instead,
  // verify that the generated elm-package.json is there, with the
  // expected version number. Iff the version number is wrong, regenerate.
  var newElmPackageDir = path.resolve(generatedCodeDir);
  var generatedSrc = path.join(newElmPackageDir, "src");

  var elmPackageContents;

  try {
    elmPackageContents = JSON.parse(fs.readFileSync(elmPackagePath, "utf8"));
  } catch (err) {
    console.error("Error reading elm-package.json: " + err);
    process.exit(1);
  }

  // Enable Native modules in the new elm-package.json, so we can import
  // the function that translates runtime exceptions into test failures.
  elmPackageContents["native-modules"] = true;

  // Make all the source-directories absolute, and introduce a new one.
  var sourceDirs = (elmPackageContents["source-directories"] || []).map(function(src) {
    return path.resolve(src)
  });

  elmPackageContents["source-directories"] = [
    // Include elm-stuff/generated-sources - since we'll be generating sources in there.
    generatedSrc,

    // Include node-test-runner's src directory, to allow access to the Runner code.
    path.resolve(path.join(__dirname, "..", "src"))
  ].concat(sourceDirs)

  fs.mkdirpSync(newElmPackageDir);

  // Generate the new elm-package.json
  fs.writeFileSync(
    path.join(newElmPackageDir, "elm-package.json"),
    JSON.stringify(elmPackageContents, null, 4)
  );

  // Copy all the native-src files over. These need to be "localized" - that is,
  // in js they cannot define things using rtfeldman$node_test_runner - but rather
  // must use the appropriate package name from the elm-package.json we're copying.
  Runner.copyNativeSrcFiles(
    Runner.repositoryToNativePackageName(elmPackageContents.repository),
    path.join(__dirname, "..", "native-src"),
    generatedSrc
  );

  process.chdir(newElmPackageDir);

  // only search testFilePaths for tests, but search all of source-directories
  // for doctests.
  // Don't bother searching a file for doctests if it's in testFilePaths!
  var srcModules = new Map();
  var visitedDirectories = new Set();

  sourceDirs.forEach(function(srcDir) {
    return Runner.addSrcFilesTo(srcModules, visitedDirectories, srcDir, srcDir);
  });

  var imports = [];
  var testList = [];
  var doctestSet = new Set(doctestModel.config.tests);

  // Building things like:
  //
  // import MyTests
  //
  // MyTests.tests
  for (var moduleName of srcModules.values()) {
    if (doctestSet.has(moduleName)) {
      moduleName = "Doc." + moduleName + "Spec";
      testList.push(moduleName + ".spec");
    } else {
      testList.push(moduleName + ".tests");
    }

    imports.push("import " + moduleName);
  }

  var testFileContents =
    [ "port module Test.Generated.Main exposing (main)"
    , ""
    , imports.join("\n")
    , ""
    , "import Test.Runner.Node"
    , "import Test"
    , "import Json.Encode"
    , ""
    , "port emit : ( String, Json.Encode.Value ) -> Cmd msg"
    , ""
    , "main : Test.Runner.Node.TestProgram"
    , "main ="
    , "    [ " + testList.join(", ") + " ]"
    , "        |> Test.concat"
    , "        |> Test.Runner.Node.run emit"
    ].join("\n");

  var testFile = path.join(generatedSrc, "Main.elm");

  fs.writeFileSync(testFile, testFileContents);

  if (args.watch) {
      infoLog('Running in watch mode');

      var watcher = chokidar.watch('**/*.elm', { ignoreInitial: true });

      var eventNameMap = {
          add: 'added',
          addDir: 'added',
          change: 'changed',
          unlink: 'removed',
          unlinkDir: 'removed',
      };

      watcher.on('all', function (event, filePath) {
          var relativePath = path.relative(elmRootDir, filePath);
          var eventName = eventNameMap[event] || event;

          infoLog('\n' + relativePath + ' ' + eventName + '. Rebuilding!');

          runTests();
      });
  }

  function runTests () {
      // TODO compile to elm-stuff/generated-code to avoid unnecessary recompilation
      temp.open({ prefix:'elm_test_', suffix:'.js' }, function(err, info) {
          var dest = info.path;
          var compileProcess = compile( [testFile], {
              output: dest,
              verbose: args.verbose,
              yes: true,
              spawn: spawnCompiler,
              pathToMake: pathToMake,
              warn:args.warn
          });

          compileProcess.on('close', function(exitCode) {
            if (exitCode !== 0) {
              console.error("Compilation failed for", testFile);
              if (!args.watch) {
                  process.exit(exitCode);
              }
            } else {
              try {
                  evalElmCode(fs.readFileSync(dest, {encoding: "utf8"}), "Main");
              } catch (err) {
                  console.error("The test run failed because it encountered a runtime exception:\n\n", err);

                  if (!args.watch) {
                      process.exit(2);
                  }
              }
            }
          });
      });
  }

  runTests();
};
